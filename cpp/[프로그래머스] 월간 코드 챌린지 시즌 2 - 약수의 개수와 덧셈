문제 설명
두 정수 left와 right가 매개변수로 주어집니다. left부터 right까지의 모든 수들 중에서, 약수의 개수가 짝수인 수는 더하고, 
약수의 개수가 홀수인 수는 뺀 수를 return 하도록 solution 함수를 완성해주세요.

제한사항
1 ≤ left ≤ right ≤ 1,000
입출력 예
left	right	result
13	17	43
24	27	52
입출력 예 설명
입출력 예 #1

다음 표는 13부터 17까지의 수들의 약수를 모두 나타낸 것입니다.
수	약수	약수의 개수
13	1, 13	2
14	1, 2, 7, 14	4
15	1, 3, 5, 15	4
16	1, 2, 4, 8, 16	5
17	1, 17	2
따라서, 13 + 14 + 15 - 16 + 17 = 43을 return 해야 합니다.
입출력 예 #2

다음 표는 24부터 27까지의 수들의 약수를 모두 나타낸 것입니다.
수	약수	약수의 개수
24	1, 2, 3, 4, 6, 8, 12, 24	8
25	1, 5, 25	3
26	1, 2, 13, 26	4
27	1, 3, 9, 27	4
따라서, 24 - 25 + 26 + 27 = 52를 return 해야 합니다.


------------------------------------------------------------------------
풀이 1
숫자가 들어왔을 때 반복문을 통해 약수의 개수를 센다.

int ans = 0;
    for(int i = 1; i <= a; i++){
        if(a % i == 0) ans++;
    }
return ans;


--------------------------------------------------------------------------
풀이 2
약수의 개수가 짝수인 수는 제곱수가 아닌 수이며, 약수의 개수가 홀수인 수는 제곱수이다.

왜 어떤 수의 제곱꼴로 나타낼 수 있는 숫자들은 약수의 갯수가 반드시 홀수 개일까 ??

그 이유는 "하나의 숫자로 표현이 가능" 하기 때문이다.
숫자 '10'을 생각해보자. 약수는 [ 1 , 2 , 5 , 10 ] 이 있는데, 이 약수들은 2개씩 짝을 지어야만 '10'을 표현할 수가 있다.
1과 10을 곱해서 10을 만들 수 있고, 2와 5를 곱해서 10을 만들 수 있다.
즉 ! 반드시 짝수개가 있어야만 해당 숫자를 표현할 수 있기 때문에 어떤 수의 제곱꼴로 나타낼 수 없는 숫자들은 반드시 약수의 갯수가 짝수개가 된다.

숫자 '16'을 생각해보자. 약수는 [ 1 , 2 , 4 , 8 , 16 ] 이 있는데, 이 약수들 중에서 특정 숫자는 하나의 숫자만으로도 '16'을 표현할 수가 있다.
1과 16을 곱해서 16을 만들 수 있고 , 2와 8을 곱해서 16을 만들 수 있지만, '4'같은 경우에는 4혼자만으로도 4^2으로 16을 만들 수 있다. 
즉 ! 이것 때문에 어떤 수의 제곱꼴로 나타낼 수 있는 숫자들은 약수의 갯수가 반드시 홀수개라는 특징이 있다.

** 제곱수인지 판별 -> 루트를 씌운 후 정수인지 확인!

#include <string>
#include <vector>
#include <math.h>
using namespace std;
int arr[1001];
bool solve(int a){
    double num = sqrt(a);
    if(double(num - int(num)) == 0) return 1;  // 제곱수 -> 홀수 약수
    else return 0;  // 짝수 약수
}
int solution(int left, int right) {
    int answer = 0;
    for(int i = left ; i <= right; i++){
        if(solve(i)) answer -= i;
        else answer += i;
    }
    return answer;
}
    
